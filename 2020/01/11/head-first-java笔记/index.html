<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    Hexo
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="miccall" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 4.2.0"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">URIEL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Java/">Java</a></li><li><a class="category-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a></li><li><a class="category-link" href="/categories/%E6%95%B0%E5%AD%A6/">数学</a></li><li><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/Chenshasan/Typora-Lotebook-of-LGL" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="http://500px.com" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(http://b165.photo.store.qq.com/psb?/V13cLEEU1KBTPJ/wdLeyZqNQkIMHoiVBAJqLUBnRHTSRquwGysp03d9Ewo!/b/dE*NY2ItBwAA&amp;bo=IANYAgAAAAABB1k!&amp;rf=viewer_4);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >head first java笔记</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h2 id="head-first-java笔记"><a href="#head-first-java笔记" class="headerlink" title="head first java笔记"></a>head first java笔记</h2><h3 id="1-breadking-the-surface"><a href="#1-breadking-the-surface" class="headerlink" title="1.breadking the surface"></a>1.breadking the surface</h3><p>java工作方式，输入源代码，通过编译器将源代码编译成字节码，再用JVM使用字节码展示出最后的结果</p>
<h3 id="2-A-trip-to-objectville"><a href="#2-A-trip-to-objectville" class="headerlink" title="2.A trip to objectville"></a>2.A trip to objectville</h3><p>设计类时，考虑：things the object konws和things the object does</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1569745918022.png" alt="1569745918022"></p>
<p>类不是对象，类指导对象的生成——class is a blueprint of object</p>
<p>对象和对象之间talks，main函数的主要作用仅仅是启动java程序以及检测实例类</p>
<h3 id="3-Know-your-variables"><a href="#3-Know-your-variables" class="headerlink" title="3.Know your variables"></a>3.Know your variables</h3><p>primitive variable和reference variable，在类中均为instance variable</p>
<p>变量保留码</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1569747911094.png" alt="1569747911094"></p>
<h3 id="2-A-trip-to-objectville-1"><a href="#2-A-trip-to-objectville-1" class="headerlink" title="2.A trip to objectville"></a>2.A trip to objectville</h3><h3 id="4-how-objects-behave"><a href="#4-how-objects-behave" class="headerlink" title="4.how objects behave"></a>4.how objects behave</h3><p>method可以传入一些参数，同时返回一些东西</p>
<p>java ——pass by value即pass by copy</p>
<p>若传入的是基本变量，则改变基本变量的参数值的时候并不改变原参数的值，但若传入的是引用变量，引用变量的copy仍然指向同一个对象，则在方法中可以改变该对象的值</p>
<p>封装</p>
<ul>
<li>使用private来修饰类中的instance variable可以起到封装作用；使用有public修饰的getter和setter方法可以获取该类或者修改该类</li>
<li>instance variable 是在类中声明，local variable则是在方法中声明；instance variable具有默认值，而local variable没有默认值，必须初始化，默认值列表如下</li>
</ul>
<img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/Users\李甘霖\AppData\Roaming\Typora\typora-user-images\1569754031680.png" alt="1569754031680" style="zoom:50%;">

<h3 id="5-extra-strength-methods"><a href="#5-extra-strength-methods" class="headerlink" title="5.extra strength methods"></a>5.extra strength methods</h3><p>设计一个类的步骤：</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1569749606420.png" alt="1569749606420"></p>
<p>伪代码的主要构成：变量的声明；方法的声明；方法的逻辑</p>
<h3 id="6-java-API"><a href="#6-java-API" class="headerlink" title="6.java API"></a>6.java API</h3><p>对ArrayList的基本操作：</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1569754473104.png" alt="1569754473104"></p>
<p>除了java.lang之外，使用其他包的内容时需要对java其他包做引入</p>
<p>使用HTML api文档来调用api，查阅api的内容</p>
<h3 id="7-better-living-in-objectville"><a href="#7-better-living-in-objectville" class="headerlink" title="7.better living in objectville"></a>7.better living in objectville</h3><p>继承的要求：能够共用一些相同的特性；在逻辑上有从抽象到具体的关系</p>
<p>继承了同一类A的类B，C，D都能够通过is a A的测试</p>
<p>四种access level：public private protected default</p>
<p>override即为子类重写父类的方法，且override的限制条件有1.两种方法的传入参数要相同，且return的形式要兼容2.两种方法的access level要相同</p>
<p>多态：同一个reference能够调用继承同一类的不同的类</p>
<img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/Users/李甘霖/Dropbox/Typora-Lotebook-of-LGL/java/head first java笔记.assets/1570532597673.png" alt="1570532597673" style="zoom:50%;">

<p>overloading：两个方法具有相同的名字但有不同的传参，限制条件：不能只改变return type，本质上还是两个不同的方法</p>
<h3 id="8-interface-and-abstract-classes"><a href="#8-interface-and-abstract-classes" class="headerlink" title="8.interface and abstract classes"></a>8.interface and abstract classes</h3><p>声明抽象类，一个抽象类可以含有抽象方法和非抽象方法</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1570534286024.png" alt="1570534286024"></p>
<p>abstracrt method</p>
<ul>
<li><p>这个方法必须被override，这个方法没有body，如果声明了抽象方法，那必须声明抽象类，即一个抽象方法只可能在一个抽象类里面出现</p>
</li>
<li><p>继承树中第一个concrete 类必须实现之前所有父类的abstract 方法</p>
</li>
</ul>
<p>所有的类都继承object类，object类有四种基本方法：</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1570535522662.png" alt="1570535522662"></p>
<p>将更generic的类具体化需要使用强制转换</p>
<p>当抽象类被实例化了之后，抽象类中的方法是可以直接通过抽象类的引用调用的</p>
<p>interface</p>
<ul>
<li><p>是一个继承关系中类似于父类的存在，但因为interface中所有方法均为abstract的，所以所有的ineterface的方法均需要被重写</p>
</li>
<li><p>基本上任何类都可以实现相同的interface，且一个类可以实现多个interface</p>
</li>
</ul>
<h3 id="9-constructors-and-garbage-collection"><a href="#9-constructors-and-garbage-collection" class="headerlink" title="9.constructors and garbage collection"></a>9.constructors and garbage collection</h3><p>栈和堆</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1570538970410.png" alt="1570538970410"></p>
<ul>
<li><p>如果一个局部变量被声明为一个对象，那么只有这个引用本身在栈上，其指向的对象在堆上</p>
</li>
<li><p>全局变量在堆上，在它所隶属的对象里</p>
</li>
</ul>
<p>构造函数：constructor 在使用new时，jvm会调用构造函数</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1570622285239.png" alt="1570622285239"></p>
<ul>
<li>constructor类似于方法，但没有返回类型，因为在外部调用返回之前构造函数就已经完成了构造</li>
<li>构造函数可用于初始化一些值或者输出</li>
<li>constructor可以被overload</li>
<li>instance variable能够有默认值，为0或者Null</li>
<li>如果一个子类的constructor被使用了，那么它将唤醒所有父类的constructor</li>
<li>如果子类使用constructor的时候没有call super()，那编译器会自动call super()，并且call super()是所有constructor最先完成的事，因此只有当父类constructor完成时，子类的constructor才会被完成</li>
<li>当子类继承了父类的getter但没有继承父类的私有变量时，子类继承的方法会去通过super调用父类的方法</li>
<li>在构造函数中this()\super()都必须是第一声明，因此不能重复在一个构造函数中同时调用this()\super()</li>
</ul>
<p>垃圾回收机制</p>
<ul>
<li>对象的存在时间是当其没有被引用时，将会被回收</li>
<li>方法中的变量不能够互相调用，在某一方法中调用其他方法时，只要方法还在栈中，其局部变量还是存在（只是不能被其他方法调用）</li>
</ul>
<h3 id="10-numbers-and-statics"><a href="#10-numbers-and-statics" class="headerlink" title="10.numbers and statics"></a>10.numbers and statics</h3><p>static方法</p>
<ul>
<li>即为不依赖类中任何全局变量的方法，因此static方法不需要通过创造对象然后通过对象名调用，而是直接通过类名调用</li>
<li>如Math类中的方法直接通过类名调用，且Math类中地constructor被设定为private，即Math类不能被new</li>
<li>静态方法也不能调用非静态方法</li>
</ul>
<p>static变量</p>
<ul>
<li>one value for one class instead of one value for one instance</li>
<li>static变量只在类被加载的时候初始化，而不是在对象被创建的时候都初始化</li>
<li>初始化顺序：static变量=&gt;static方法/object</li>
<li>访问static变量时也像static方法一样直接通过类名调用</li>
<li>static变量也有初始值</li>
</ul>
<p>final修饰符：表明变量被声明以后就不能更改，方法被声明后不能再被voerride，类被声明后不能再被继承</p>
<p>static final表示这个变量不能更改且和整个类保持相同的存在时间，且该变量必须在初始化的时候声明，有如下两种声明方式</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1570948190324.png" alt="1570948190324"></p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1570948202312.png" alt="1570948202312"></p>
<p>Math类中的方法：</p>
<ul>
<li>Math.random()（随机取值）</li>
<li>Math.abs()（取绝对值）</li>
<li>Math.min()</li>
<li>Math.max()</li>
<li>Math.round()（取整）</li>
</ul>
<p>基本数据类型的打包：（将基本数据类型当做对象处理）</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1570948899329.png" alt="1570948899329"></p>
<p>Autobox：将基本数据类型和对象类型能够一起使用，即在使用wrapper对象的时候和基本类型是互相兼容的，如传参，返回参数时</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1570951800631.png" alt="1570951800631"></p>
<p>以下为autobox所使用的范围</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1570952047346.png" alt="1570952047346"></p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1570952107092.png" alt="1570952107092"></p>
<p>wrapper对象也拥有static方法，如</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1570952203176.png" alt="1570952203176"></p>
<p>Sring.format()方法：将数字也通过string的方法输出</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571144332596.png" alt="1571144332596"></p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571144405636.png" alt="1571144405636"></p>
<p>format的主要形式：format中precision是强制必须有的，%d代表十进制，%f代表浮点数，%x代表十六进制，%c代表char</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571217032361.png" alt="1571217032361"></p>
<p>当用format表示日期时，为</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571217524245.png" alt="1571217524245"></p>
<p>可使用Calender包表示java日期，但Calender类是抽象的，因此使用getInstance方法来实例化Calender的子类</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571217902245.png" alt="1571217902245"></p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571218203117.png" alt="1571218203117"></p>
<h3 id="11-exception-handling"><a href="#11-exception-handling" class="headerlink" title="11.exception handling"></a>11.exception handling</h3><p>java sound API:MIDI 对于声音进行处理，然后将该数据通过MIDI播放器播放出来，sequencer是将数据顺序化处理以便于其播放出完整音乐</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571226092336.png" alt="1571226092336"></p>
<p>启动播放：</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571226177832.png" alt="1571226177832"></p>
<p>MIDIevent信息：（MIDImessage：表明做什么）和什么时候开始做</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571226458251.png" alt="1571226458251"></p>
<p>MIDImessage包含信息：</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571226683277.png" alt="1571226683277"></p>
<p>异常处理：</p>
<ul>
<li><p>异常可由方法抛出，抛出该异常前必须声明，异常会被抛出到方法的调用者，调用者可通过try/catch处理。</p>
</li>
<li><p>所有的异常都会被编译器检测出来，除了runtime exception</p>
</li>
<li><p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571223010464.png" alt="1571223010464"></p>
</li>
<li><p>finally块的代码在不管是否抛出异常时都执行</p>
</li>
<li><p>多异常处理：先处理小的异常再处理大的异常</p>
</li>
<li><p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571223601060.png" alt="1571223601060"></p>
</li>
<li><p>在抛出异常和接收异常时，都能够通过父类的类型来抛出（捕获）子类的类型</p>
</li>
<li><p>如果方法中调用的其他方法抛出异常且该方法不想处理该异常，则该方法也声明抛出异常即可，但main必须处理所有的异常</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571225623630.png" alt="1571225623630"></p>
</li>
<li><p>其余规则：<img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571225928801.png" alt="1571225928801"></p>
</li>
</ul>
<h3 id="12-getting-gui"><a href="#12-getting-gui" class="headerlink" title="12.getting gui"></a>12.getting gui</h3><p>基本的gui界面：</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571302099148.png" alt="1571302099148"></p>
<p>在画基本界面时Jframe必须要getContentPane以及setSize和setVisible，才能将Jframe表示出来</p>
<p>widget包括 ：JButton,JRadioButton,JCheckBox,JLable,JList,JScrollPane,JSider,JTextField,JTextArea,JTable</p>
<ul>
<li>监听Jbutton按钮事件是否被触发——listener interface，回调函数就在这个interface中</li>
<li>在Java中一个事件被认为是一个对象，每种事件类型都对应一个listener interface</li>
<li>每个事件类型中都有可能有多种方法，如移到鼠标上，点击鼠标等</li>
<li>button通过addActionListener添加接口，actionperformed方法能够被传入源事件（如鼠标点击等），然后触发新的事件</li>
</ul>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571303047048.png" alt="1571303047048"></p>
<p>调用listener：</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571303158816.png" alt="1571303158816"></p>
<p>在Jpanel上画图形：</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571304775494.png" alt="1571304775494"></p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571304808041.png" alt="1571304808041"></p>
<p>关于Graphics: </p>
<ul>
<li>grapfics2D的方法包括： fill3DRect(), draw3DRect(), rotate(), scale(), shear(), transform( )</li>
<li>graghics2D的方法使用时必须将graghics类强制转换成graphic2D类型，这样才能使用graphics2D类型的方法</li>
<li>在Jpanel上面画图形时，使用类继承jpanel类，然后再override Jpanel的paintComponent方法，并且这个方法有一个自动传入的参数grphics</li>
</ul>
<p>实现多个button的监听：</p>
<ul>
<li>通过内部类来实现，内部类能够访问frame等参数的方法同时能够调用不同的Interface，则实现多个监听即创建不同的listener类来实现ActionListener（actionperformed方法是在listener类中的）</li>
<li>内部类在其外部类中实现时必须实例化，而且实例化的空间用的是外部类的变量空间</li>
</ul>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571396512688.png" alt="1571396512688"></p>
<p>实现message events：在sequence上添加ActionListener，可以用来监听，如controllerChange就是对于该接口方法的重写</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571398867356.png" alt="1571398867356"></p>
<p>如果该声音信息需要修改面板，可直接添加内部类监听controllerChange，如果有MIDIevent则修改面板信息</p>
<h3 id="13-using-swing"><a href="#13-using-swing" class="headerlink" title="13.using swing"></a>13.using swing</h3><p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571401860790.png" alt="1571401860790"></p>
<p>layout manager——在询问组件的要求之后，自行对于页面的布局进行排布和调整</p>
<p>三种layout布局形式：</p>
<ul>
<li><p>border layout，分为5个布局块，每个布局块都只能放置一个组件（北边和南边的版块获得他们想要的高度，而东边和西边的版块获得想要的宽度，中间的版块获得剩下的部分）</p>
</li>
<li><p>flow layout，水平布局块，layout的默认布局方式，先水平排布，当水平排布已经到达一行的最大限度时再往下排布</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571403285895.png" alt="1571403285895"></p>
</li>
<li><p>box layout，垂直排布，每一行只能有一个组件</p>
</li>
</ul>
<p>在panel中设置boxLayout:</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571403650503.png" alt="1571403650503"></p>
<p>对于jTextField：</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571973573467.png" alt="1571973573467"></p>
<p>使用JTextArea:</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571974763661.png" alt="1571974763661"></p>
<p>JCheckBox:</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571974935387.png" alt="1571974935387"></p>
<p>JList:</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571974999062.png" alt="1571974999062"></p>
<p>GUI的确立顺序基本为：frame,layout,jpanel(add layout)，其他组件（如jTextArea需要先在scrollbar中被确定，botton，box等）</p>
<p>栅栏组件的添加：</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571976026524.png" alt="1571976026524"></p>
<h3 id="14-serialization-and-file-I-O"><a href="#14-serialization-and-file-I-O" class="headerlink" title="14.serialization and file I/O"></a>14.serialization and file I/O</h3><ul>
<li>当文件仅被其他java文件使用时，serialization，即用一个文件保存该序列化文件再被其他java文件启用即可</li>
<li>当文件被其他语言文件应用，写成plain text 文件</li>
</ul>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571981914941.png" alt="1571981914941"></p>
<p>文件的序列化输出为：先用一个fileOutPutStream来连接其他文件，再用ObjectOutPutStream来写入object并连接FileOutPutStream，写完后关闭ObectOutPutStream</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571982179400.png" alt="1571982179400"></p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571982413918.png" alt="1571982413918"></p>
<ol>
<li><p>序列化自动的过程是：序列化一个类，并且这个类中引用的所有类，以及引用类中的所有类都会被序列化</p>
</li>
<li><p>实现序列化时，需要声明该类是implements serializable，且接口的实现时可以继承的，即父类实现了该接口，子类无需声明也自动实现该接口</p>
</li>
<li><p>如果可序列化的类中调用了其他的不可序列化的类，会报错</p>
</li>
<li><p>将变量声明为transient即可在序列化的过程中跳过该变量</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571983579663.png" alt="1571983579663"></p>
</li>
</ol>
<p>还原序列化：需要读取object并且将该object强制转化</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571983818472.png" alt="1571983818472"></p>
<p>对于file类可以有如下操作：file类更类似于一个文件的地址，而不是文件本身</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571986480229.png" alt="1571986480229"></p>
<p>Buffer：类似于cache，可以先将数据缓存在buffer中，再将buffer连接到file上</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571986879575.png" alt="1571986879575">对于文件的读写有fileWrite和fileReader，相应的也有BufferWrier和BufferReader</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571987104700.png" alt="1571987104700"></p>
<p>解序列化出错：序列化一个对象之后，修改了该对象的类，再用修改后的类解序列化该对象会出错，以下方式会导致解序列化的出错：</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571987855481.png" alt="1571987855481"></p>
<p>版本控制序列号：serial vision UID</p>
<p>当对于一个对象进行了序列化之后，如果后来的类修改了，原则上需要修改版本序列号，表明该类与原对象不兼容，此时JVM不会编译，但是当该类不修改版本序列号时，JVM会编译，此时需要注意修改后的类仍然需要能够处理该对象的解序列化</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/1571988178952.png" alt="1571988178952"></p>
<h3 id="15-networking-and-threads"><a href="#15-networking-and-threads" class="headerlink" title="15.networking and threads"></a>15.networking and threads</h3><p>服务器与客户端的基本工作原理：服务器接收所有客户端的消息并同步给所有客户端</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/image-20191104120717499.png" alt="image-20191104120717499"></p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>客户端如何具体地连接到服务器并输入与输出信息：</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/image-20191104121155766.png" alt="image-20191104121155766"></p>
<p>socket能够建立服务端和客户端之间的联系，让两边都能够连接到对方：</p>
<ul>
<li><p>Socket中的数据是服务器的数据，能够让客户端连接到服务器，服务器通过等待请求以后再建立一个Socket即可</p>
</li>
<li><p>TCP port能够使用从0到65535中间的任何数组，但是0到1023是用于被公认的服务请求，所以一般使用104到65535中间的数字</p>
</li>
<li><p>IP地址确定一个具体的位置，而TCP port则确定具体位置的具体方式/地点</p>
</li>
</ul>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/image-20191104121455583.png" alt="image-20191104121455583"></p>
<p>通过BufferReader从socket上面读取信息：</p>
<ol>
<li>建立socket联系</li>
<li>从socket上读取inputStream</li>
<li>通过BufferReader储存输入流的信息，同时读取BufferReader的信息</li>
</ol>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/image-20191104131624705.png" alt="image-20191104131624705"></p>
<p>通过WriterPrint输送信息到Socket上</p>
<ol>
<li>建立Socket联系</li>
<li>建立PrintWriter</li>
<li>写PrintWriter</li>
</ol>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/image-20191104132007709.png" alt="image-20191104132007709"></p>
<h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><ol>
<li>建立服务器的ServerSocket</li>
<li>通过clinet的Socket建立一个新的Socket和客户端交流</li>
</ol>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/image-20191104132605402.png" alt="image-20191104132605402"></p>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>java通过线程实现多步同时进行，通过java类Thread的实例化构建新进程即可</p>
<p>新的进程也占用栈中的内存，且在调用新进程时，主进程是被停止的：</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/image-20191104143413978.png" alt="image-20191104143413978"></p>
<p>开始一个进程的步骤：</p>
<ol>
<li>通过Runnable类创建对象，明确进程的任务</li>
<li>创建进程</li>
<li>开启进程</li>
</ol>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/image-20191104143547360.png" alt="image-20191104143547360"></p>
<p>通过自己定义类继承Runnable接口，在该类中的run和go方法中明确要做的任务，然后通过线程类来启动runnable类</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/image-20191104144052109.png" alt="image-20191104144052109"></p>
<ul>
<li><p>线程控制器能够选择运行什么线程，线程控制器在不同的JVM上面可能不一样，因此相同的程序在不同的JVM上跑可能会有不一样的结果</p>
</li>
<li><p>thread.sleep（毫秒数）能够使线程停止该毫秒数的时间，当其醒过来后会再次进入到runnable state，等到线程控制器再次调用这个线程</p>
</li>
<li><p>可以通过sleep来调控线程进行的先后顺序</p>
</li>
</ul>
<h4 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h4><p>当几个线程都调用同一个数据时，在一个线程对一个数据调用的过程中，应该对其有线程锁，防止其他线程调用</p>
<ul>
<li>有线程锁的方法用synchronized修饰</li>
<li>线程锁是每个类所具有的的，不是每个synchronized方法锁具有的，也就是当一个线程访问了该类的synchronized方法，这个类的线程锁被锁起来，在synchronized方法访问完之前，其他的任何线程都不能访问该类的任何一个synchronized方法</li>
<li>线程死锁：两个进程同时都没有进行完，但都同时拥有对方能进行完的钥匙，所以会产生死循环式的等待</li>
</ul>
<h3 id="16-connections-and-generics"><a href="#16-connections-and-generics" class="headerlink" title="16.connections and generics"></a>16.connections and generics</h3><h4 id="connections-种类"><a href="#connections-种类" class="headerlink" title="connections 种类"></a>connections 种类</h4><p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/image-20191118145419749.png" alt="image-20191118145419749"></p>
<p>java.util.connections方法：</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/image-20191118145941962.png" alt="image-20191118145941962"></p>
<p>树在添加时是按照顺序排列好的——treeset</p>
<p>list添加时直接排列在最后端，因此知道排列在哪，但不知道顺序</p>
<h4 id="generics"><a href="#generics" class="headerlink" title="generics"></a>generics</h4><p>能够使得collections变得更为安全，限制collections中储存的object的性质</p>
<img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/Users/李甘霖/Dropbox/Typora-Lotebook-of-LGL/java/head first java笔记.assets/image-20191118150923879.png" alt="image-20191118150923879" style="zoom: 33%;">

<p>genercis的使用</p>
<ol>
<li>创建的如arraylist的列表用generic创立</li>
<li>声明更为generic的项</li>
<li>使用方法传输参数为更为generic的object</li>
</ol>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/image-20191118151623102.png" alt="image-20191118151623102"></p>
<p>对于arrayList的使用：</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/image-20191118151752472.png" alt="image-20191118151752472"></p>
<h4 id="使用generic的方法："><a href="#使用generic的方法：" class="headerlink" title="使用generic的方法："></a>使用generic的方法：</h4><p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/image-20191118154157023.png" alt="image-20191118154157023"></p>
<p>上一种方法能够传递多态的元素，而下一种不可以</p>
<p>collections的sort()声明是</p>
<p><img src="/2020/01/11/head-first-java%E7%AC%94%E8%AE%B0/image-20191118154358403.png" alt="image-20191118154358403"></p>
<p>因此sort方法仅能传递容纳可以比较的object 的list</p>

            </div>

            <!-- Post Comments -->
            

        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " target="_blank" rel="noopener" style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
