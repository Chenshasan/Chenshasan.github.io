<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    Hexo
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="miccall" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 4.2.0"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">URIEL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Java/">Java</a></li><li><a class="category-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a></li><li><a class="category-link" href="/categories/%E6%95%B0%E5%AD%A6/">数学</a></li><li><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/Chenshasan/Typora-Lotebook-of-LGL" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="http://500px.com" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(http://b165.photo.store.qq.com/psb?/V13cLEEU1KBTPJ/3PqLppmDJ1w0fRWxT1nH6rjEvgu.obX*1QE3IrTgQFI!/b/dHS0Y2JrCQAA&amp;bo=IANYAgAAAAABB1k!&amp;rf=viewer_4);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >离散数学(2)</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h2 id="离散数学（2）"><a href="#离散数学（2）" class="headerlink" title="离散数学（2）"></a>离散数学（2）</h2><h3 id="第七章：树"><a href="#第七章：树" class="headerlink" title="第七章：树"></a>第七章：树</h3><h4 id="Trees"><a href="#Trees" class="headerlink" title="Trees"></a>Trees</h4><p>定义：一棵树中有一个节点，这个节点到任意其他节点都有路径，但这些节点都不能到这个根节点</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191125210700910.png" alt="image-20191125210700910"></p>
<p>父节点：parent</p>
<p>子节点：offspring </p>
<p>兄弟节点：siblings</p>
<p>叶节点：leaves </p>
<p>THEOREM 2</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191126105845318.png" alt="image-20191126105845318"></p>
<p>对于一个树，除了它的叶节点，其他的所有节点都含有n个子节点，则被称为complete n trees</p>
<p>THEOREM 3</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191126111445343.png" alt="image-20191126111445343"></p>
<h4 id="Ordered-trees"><a href="#Ordered-trees" class="headerlink" title="Ordered trees"></a>Ordered trees</h4><p>eg:</p>
<img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/Users/李甘霖/Dropbox/Typora-Lotebook-of-LGL/数学/离散数学.assets/image-20191126113252922.png" alt="image-20191126113252922" style="zoom:50%;">

<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191126113309296.png" alt="image-20191126113309296"></p>
<p>positional trees:每一个节点的子节点有固定的配列顺序和位置的树</p>
<h5 id="Binary-positional-trees-as-data-structures"><a href="#Binary-positional-trees-as-data-structures" class="headerlink" title="Binary positional trees as data structures"></a>Binary positional trees as data structures</h5><p>linked lists and double linked lists</p>
<p>double linked lists的演示图：</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191126113924876.png" alt="image-20191126113924876"></p>
<p>double linked list的重点在于其左指针和右指针都可以指向不同的节点，因此形成了一个树状</p>
<h5 id="Huffman-code-tree"><a href="#Huffman-code-tree" class="headerlink" title="Huffman code tree"></a>Huffman code tree</h5><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/Users/李甘霖/Dropbox/Typora-Lotebook-of-LGL/数学/离散数学.assets/image-20191126162535442.png" alt="image-20191126162535442" style="zoom: 67%;">

<p>霍夫曼树形成的代码，0表示往左，1表示往右，最终由01串形成代码串</p>
<h4 id="Tree-searching"><a href="#Tree-searching" class="headerlink" title="Tree searching"></a>Tree searching</h4><p>遍历树，进行树的搜索</p>
<h5 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h5><p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191126164035503.png" alt="image-20191126164035503"></p>
<p>线性表示的prefix/polish form</p>
<img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/Users/李甘霖/Dropbox/Typora-Lotebook-of-LGL/数学/离散数学.assets/image-20191126164616648.png" alt="image-20191126164616648" style="zoom:67%;"> 

<p>通过前序搜索实现算术树的遍历，然后得出prefix/polish form</p>
<h5 id="inorder和postorder"><a href="#inorder和postorder" class="headerlink" title="inorder和postorder"></a>inorder和postorder</h5><p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191126164706843.png" alt="image-20191126164706843"></p>
<p>infix notation中序遍历生成的线性表示</p>
<p>postfix /reverse polish后序遍历生成的线性表示</p>
<h5 id="多节点树的搜索方法："><a href="#多节点树的搜索方法：" class="headerlink" title="多节点树的搜索方法："></a>多节点树的搜索方法：</h5><p>通过左子女右兄弟的方法遍历节点——linked list representation of T</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191126165558885.png" alt="image-20191126165558885"></p>
<h4 id="Undirected-trees"><a href="#Undirected-trees" class="headerlink" title="Undirected trees"></a>Undirected trees</h4><p>simple：当一颗树中的一个edge不会被其他的两个或者多个edge替代时，称这课树为simple，如果这条路径是一个环，则成为simple cycle</p>
<p>acyclic：对于一个对称关系，被称为acyclic是在其不含有simple cycle时</p>
<p>THEOREM 1</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191126171627532.png" alt="image-20191126171627532"></p>
<p>THEOREM 2</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191126171840874.png" alt="image-20191126171840874"></p>
<p>THEOREM 3</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191126171855910.png" alt="image-20191126171855910"></p>
<p>将树变为simple的办法：从undirected tree中移除树节点，直到最后的树中再移除任何一个节点都变得不connected</p>
<h5 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h5><p>对于非simple的树中的节点进行merge的merge操作：</p>
<p>需要的条件为merge后的节点，其进入的节点数为之前两节点数相加，出的节点为之前两节点数的出节点相加</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191126193635668.png" alt="image-20191126193635668">在矩阵中进行的操作即为：将该节点对应的矩阵的两行相加，两列相加，合成新的一个矩阵</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191126194042073.png" alt="image-20191126194042073"></p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191126194053867.png" alt="image-20191126194053867"></p>
<h5 id="Prim’s-algorithm"><a href="#Prim’s-algorithm" class="headerlink" title="Prim’s algorithm"></a>Prim’s algorithm</h5><h4 id="Minimal-spanning-trees"><a href="#Minimal-spanning-trees" class="headerlink" title="Minimal spanning trees"></a>Minimal spanning trees</h4><p>weighted grapg:edge标有数量的图表</p>
<p>distance between vetices</p>
<p>nearest neighbor of vertex</p>
<h5 id="minimal-spanning-trees"><a href="#minimal-spanning-trees" class="headerlink" title="minimal spanning trees:"></a>minimal spanning trees:</h5><p>一个undirected tree，且其edge之和最小</p>
<h5 id="Prim’s-algorithm-1"><a href="#Prim’s-algorithm-1" class="headerlink" title="Prim’s algorithm"></a>Prim’s algorithm</h5><p>基本逻辑为：从一个节点开始，把这个节点所有相邻且不形成环的节点加入，最后直到这课树囊括所有节点</p>
<p>也是greedy algorithm的一种</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191128081655071.png" alt="image-20191128081655071"></p>
<p>THEOREM 1</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191128082305527.png" alt="image-20191128082305527"></p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191128082757564.png" alt="image-20191128082757564"></p>
<h5 id="Kruskal’s-algorithm"><a href="#Kruskal’s-algorithm" class="headerlink" title="Kruskal’s algorithm"></a>Kruskal’s algorithm</h5><p>对于所有的边，选取其中的n-1条，每一条边增加时都不能形成环，最后形成完整的最小生成树</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191203171816451.png" alt="image-20191203171816451"></p>
<h3 id="第八章-：graphs"><a href="#第八章-：graphs" class="headerlink" title="第八章 ：graphs"></a>第八章 ：graphs</h3><h4 id="Graphs"><a href="#Graphs" class="headerlink" title="Graphs"></a>Graphs</h4><p>基本概念</p>
<ul>
<li>graph——vertices——edges</li>
<li>用（V,E,γ）来表示图中一个局部的关系 </li>
<li>degree of vertices</li>
<li>loop</li>
<li>isolated vertex</li>
<li>adjacent vertices</li>
<li>circuit:circle</li>
<li>simple circuit</li>
</ul>
<h5 id="Vπ-Eπ-path："><a href="#Vπ-Eπ-path：" class="headerlink" title="(Vπ,Eπ)path："></a><strong>(V<sub>π</sub>,E<sub>π</sub>)path：</strong></h5><p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191203195613253.png" alt="image-20191203195613253"></p>
<ul>
<li>在该路径中所有的节点都是相邻的，且是通过E<sub>π</sub>中的边依次相邻的</li>
<li>每个节点都只在该节点序列中出现一次</li>
</ul>
<h5 id="特殊图表"><a href="#特殊图表" class="headerlink" title="特殊图表"></a>特殊图表</h5><p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191203195914844.png" alt="image-20191203195914844"></p>
<img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/Users/李甘霖/Dropbox/Typora-Lotebook-of-LGL/数学/离散数学.assets/image-20191203195923914.png" alt="image-20191203195923914" style="zoom:50%;">

<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191203195937284.png" alt="image-20191203195937284"></p>
<h5 id="subgraph-quotient-graph"><a href="#subgraph-quotient-graph" class="headerlink" title="subgraph / quotient graph"></a>subgraph / quotient graph</h5><p>subgraph:子图，对于一个graph，其disconnected的子图为一个component</p>
<p>quotient graph：对于在一个图中的equivalance relation（两个相连通的节点都可以看做为一个equivalance relation），将其中的节点都合并起来，然后将其和其他节点之间的关系表示出来，如figure 15是figure 14的quotient graph</p>
<img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/Users/李甘霖/Dropbox/Typora-Lotebook-of-LGL/数学/离散数学.assets/image-20191203200653325.png" alt="image-20191203200653325" style="zoom:50%;">

<h4 id="Eular-paths-and-circuits"><a href="#Eular-paths-and-circuits" class="headerlink" title="Eular paths and circuits"></a>Eular paths and circuits</h4><p>eular path：在路径中每个edge只出现一次且至少出现一次的path</p>
<p>eular circuit：eular path组成的circuit</p>
<p>——欧拉路径的本质应为在一个图中，找出能够遍历完所有图的edge且不出现重复edge的path</p>
<p>THEOREM 1</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191203205812663.png" alt="image-20191203205812663"></p>
<p>基本证明逻辑为：若所有的节点都有偶数条边，则在对所有的节点使用了一条边之后，也能够对所有的节点使用剩余的没有使用的边来组成另一条path</p>
<p>THEOREM 2</p>
<p>欧拉路径的本质也是欧拉循环再添加edge，如果添加成了有多个odd degree的节点，则无法形成欧拉路径</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191203210400697.png" alt="image-20191203210400697"></p>
<h5 id="FLEURY’S-ALGORITHM"><a href="#FLEURY’S-ALGORITHM" class="headerlink" title="FLEURY’S ALGORITHM"></a>FLEURY’S ALGORITHM</h5><p>通过行走edge，然后将走过的edge移除，再将edge被遍历完的isolated的节点移除，直到走完所有的节点</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191203211840582.png" alt="image-20191203211840582"></p>
<h4 id="Hamiltonian-paths-and-circuits"><a href="#Hamiltonian-paths-and-circuits" class="headerlink" title="Hamiltonian paths and circuits"></a>Hamiltonian paths and circuits</h4><p>amiltonian paths：路径中每个节点出现一次</p>
<p>hamiltonian circuit：成环的hamiltonian path</p>
<p>THEOREM 1</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191204211200570.png" alt="image-20191204211200570"></p>
<p>相同意义表达为：</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191204211411194.png" alt="image-20191204211411194"></p>
<p>THEOREM 2</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191204211451327.png" alt="image-20191204211451327"></p>
<h4 id="Transport-network"><a href="#Transport-network" class="headerlink" title="Transport network"></a>Transport network</h4><h5 id="transport-network"><a href="#transport-network" class="headerlink" title="transport network"></a>transport network</h5><ol>
<li>存在一个源节点source,in-degree为0</li>
<li>存在一个最终的节点sink，out-degree为0</li>
<li>C<sub>ij</sub>被称为是edge的capacity</li>
</ol>
<h5 id="flow"><a href="#flow" class="headerlink" title="flow"></a>flow</h5><p>F<sub>ij</sub>是指一个图中相对应的edge的流量，流量不超过容量</p>
<ul>
<li>对一个节点来说，流进的流量等于流出的流量</li>
<li>流量不能储存、创造、凭空消失·</li>
</ul>
<h5 id="the-labeling-algorithm"><a href="#the-labeling-algorithm" class="headerlink" title="the labeling algorithm"></a>the labeling algorithm</h5><p>寻找一个图中能有的最大流量的算法</p>
<ul>
<li>将与source节点连接的所有节点标定为[E<sub>j</sub>，1]（j为节点的编号）</li>
<li>对于与source节点连接的一个节点，对其进行标定，标定的方式为[E<sub>k</sub>,j]，E<sub>k</sub>取的是e<sub>kj</sub>的容量和Ej两个中小的哪一个（从1流向j的节点的流量，不会再增加，同时也不可能超过其容量），将这个节点连接的所有二重节点标定完之后，再标定与source节点连接的所有节点</li>
<li>重复操作，一层一层标定节点，直到所有节点完成标定</li>
<li>如果此时sink节点被标定了，则需要对于sink节点被标定的某一前一个节点，溯回到source节点，在这个路程中的所有边的capacity都减去该路径给予sink节点的流量，然后再重复最开始的过程</li>
<li>一直到sink节点最终不会再被标记，则减去的所有流量即为回路的最大流量</li>
</ul>
<h5 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h5><p>cut的定义是将一个图分为两个部分，一个部分包含sink，一个部分包含source，如果将一些edge斩断后，sink的那个部分没有流入，source的部分没有了流出，则这个容量即为the capacity of cut</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191216205630823.png" alt="image-20191216205630823"></p>
<h4 id="Matching-problem"><a href="#Matching-problem" class="headerlink" title="Matching problem"></a>Matching problem</h4><h5 id="multiple-source-and-sink"><a href="#multiple-source-and-sink" class="headerlink" title="multiple source and sink"></a>multiple source and sink</h5><p>当有多个源或者多个sink的时候，构建一个supersink和supersource,连接到所有的源或者所有的sink，则构成了labelling algorithm匹配的形式</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191216220106259.png" alt="image-20191216220106259"></p>
<h5 id="The-matching-problem"><a href="#The-matching-problem" class="headerlink" title="The matching problem"></a>The matching problem</h5><p>matching function：一种任意的匹配关系，需要是从一个集合到另一个集合的一一对应关系</p>
<p>M compatible with R：如果M被包含于R，则有M（a）所对应的b，全有a R b</p>
<p>matching problem:对于一个A R B，找到最大的满足compatible with R的M</p>
<p>THEOREM 1</p>
<p>对于一个关系R中存在match 一一对应的情况：</p>
<p>如果存在一个matching，则必有对于每个集合中的元素，其R(X)&gt;=1，且应该有R(X)总包含的元素大于M(x)的元素</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191216222105499.png" alt="image-20191216222105499"></p>
<h4 id="Coloring-graph"><a href="#Coloring-graph" class="headerlink" title="Coloring graph"></a>Coloring graph</h4><p>将color一一映射到不同的点上，为coloring the graph of G using n colors</p>
<p>chromatic number of G:对于一个图进行染色使用的最少颜色数量</p>
<h5 id="Chromatic-Polynomials"><a href="#Chromatic-Polynomials" class="headerlink" title="Chromatic Polynomials"></a>Chromatic Polynomials</h5><p>chromatic polynomail:P<sub>G</sub>(n)是使用n种或更少颜色时，能满足的G染色的所有方法</p>
<p>THEOREM 1</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191218183440993.png" alt="image-20191218183440993"></p>
<p>THEOREM 2</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191218183633905.png" alt="image-20191218183633905"></p>
<p>意思是一个图的标图方法是由一个部分的图的标图方法数乘以一个节点的标图方法数，再减去仅有的这个部分标图方法数</p>
<p>（这个部分是将这个节点merge后的部分）</p>
<h3 id="第九章：semigruops-and-group"><a href="#第九章：semigruops-and-group" class="headerlink" title="第九章：semigruops and group"></a>第九章：semigruops and group</h3><h4 id="binary-operation-revisited"><a href="#binary-operation-revisited" class="headerlink" title="binary operation revisited"></a>binary operation revisited</h4><p>binary operation:</p>
<ul>
<li>对于所有的元素均有定义</li>
<li>对于每一个pair，其结果应有一个确定值</li>
</ul>
<h5 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h5><p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191222202339918.png" alt="image-20191222202339918"></p>
<p>commutative:交换律</p>
<p>associative:结合律</p>
<p>idempotent:自反性</p>
<h4 id="Semigroups"><a href="#Semigroups" class="headerlink" title="Semigroups"></a>Semigroups</h4><p>semigroup即为一个非空的集合和一个具有结合律关系的操作方式，(S, ∗)</p>
<p>a*b是a b的product</p>
<p>free semigroup:A<sup>*</sup>即为A中元素形成的有限序列，字幕可以重复出现，·其实即为两个字母串相加</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191222212314708.png" alt="image-20191222212314708"></p>
<p>THEOREM 1</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191222215505257.png" alt="image-20191222215505257"></p>
<h5 id="identity"><a href="#identity" class="headerlink" title="identity"></a>identity</h5><p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191222215554292.png" alt="image-20191222215554292"></p>
<h5 id="monoid"><a href="#monoid" class="headerlink" title="monoid"></a>monoid</h5><p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191222215657955.png" alt="image-20191222215657955"></p>
<p>——subsemigroup/submonoid</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191222220445357.png" alt="image-20191222220445357"></p>
<h5 id="isomorphism-and-homomorphism"><a href="#isomorphism-and-homomorphism" class="headerlink" title="isomorphism and homomorphism"></a>isomorphism and homomorphism</h5><p>一般来说，在两个数学结构之间的isomorphism保留了这两个数学结构最特别的特质</p>
<img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/Users/李甘霖/Dropbox/Typora-Lotebook-of-LGL/数学/离散数学.assets/image-20191222220923514.png" alt="image-20191222220923514" style="zoom:50%;">

<p>同时f<sup>-1</sup>即为逆向的isomorphism的映射</p>
<p>判断是否为isomorphism</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191222221050384.png" alt="image-20191222221050384"></p>
<p>THEOREM 2</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191222221245223.png" alt="image-20191222221245223"></p>
<p>homomorphism</p>
<p>当去除掉isomorphism的一对一映射和满射的性质后，即为homomorphism</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191222221446497.png" alt="image-20191222221446497"></p>
<p>THEOREM 3</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191222221619779.png" alt="image-20191222221619779"></p>
<p>THEOREM 4</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191222221631725.png" alt="image-20191222221631725"></p>
<p>THEOREM 5</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191222221646286.png" alt="image-20191222221646286"></p>
<h4 id="Products-and-quotients-of-semigroups"><a href="#Products-and-quotients-of-semigroups" class="headerlink" title="Products and quotients of semigroups"></a>Products and quotients of semigroups</h4><p>THEOREM 1</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191223102439319.png" alt="image-20191223102439319"></p>
<p>congruence relation:</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191223102458959.png" alt="image-20191223102458959"></p>
<p>THEOREM 2</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191223110518603.png" alt="image-20191223110518603"></p>
<p>Corollary 1</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191223110937639.png" alt="image-20191223110937639"></p>
<p>当R是一个congruence relation on (S,*)时，满足一个quotient semigroup(S/R,  )</p>
<p>THEOREM 3</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191223112432654.png" alt="image-20191223112432654"></p>
<p>​    THEOREM 4</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191223112545635.png" alt="image-20191223112545635"></p>
<p>f的逆函数：<img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/Users/李甘霖/Dropbox/Typora-Lotebook-of-LGL/数学/离散数学.assets/image-20191223115604731.png" alt="image-20191223115604731" style="zoom:50%;"></p>
<h4 id="Groups"><a href="#Groups" class="headerlink" title="Groups"></a>Groups</h4><h5 id="Group定义"><a href="#Group定义" class="headerlink" title="Group定义"></a>Group定义</h5><p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191223131502595.png" alt="image-20191223131502595"></p>
<p>Abelian</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191223131438570.png" alt="image-20191223131438570"></p>
<p>THEOREM 1</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191223131906370.png" alt="image-20191223131906370"></p>
<p>THEOREM 2</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191223131947680.png" alt="image-20191223131947680"></p>
<p>THEOREM 3</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191223132019881.png" alt="image-20191223132019881"></p>
<p>THEOREM 4</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191223132036845.png" alt="image-20191223132036845"></p>
<h5 id="Table-1"><a href="#Table-1" class="headerlink" title="Table"></a>Table</h5><p>在群的table中可见，每一个行所对应的值都是没有重复的</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191223140829436.png" alt="image-20191223140829436"></p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191223140808590.png" alt="image-20191223140808590"></p>
<h5 id="Example-旋转三角中线"><a href="#Example-旋转三角中线" class="headerlink" title="Example:旋转三角中线"></a>Example:旋转三角中线</h5><p>定义f和g如图（类似于路线的起点和终点）</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191223141744701.png" alt="image-20191223141744701"></p>
<p>此时生成的群S为：</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191223141832121.png" alt="image-20191223141832121"></p>
<p>此时s被称为：group of symmetries of the triangle</p>
<p>s是群，因此s是associative的，但是s不是abelian的</p>
<h5 id="Subgroup"><a href="#Subgroup" class="headerlink" title="Subgroup:"></a>Subgroup:</h5><p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191223142244491.png" alt="image-20191223142244491"></p>
<p>trival subgroup:{e}</p>
<p>THEOREM 5</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191223143000599.png" alt="image-20191223143000599"></p>
<p>Z6(Z函数即为S/R中将a=b(mod 6)生成equavalence的函数)</p>
<h4 id="Products-and-quotients-of-group"><a href="#Products-and-quotients-of-group" class="headerlink" title="Products and quotients of group"></a>Products and quotients of group</h4><p>THEOREM 1</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191223171048970.png" alt="image-20191223171048970"></p>
<p>THEOREM 2</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191223191141421.png" alt="image-20191223191141421"></p>
<p>Corollary 1</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191223191923401.png" alt="image-20191223191923401"></p>
<p>coset:</p>
<p>The left coset of H in G determined by a is the set aH = {ah | h ∈ H}. </p>
<p>The right coset of H in G determined by a is the set Ha = {ha | h ∈ H}</p>
<p>THEOREM 3</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191223192555600.png" alt="image-20191223192555600"></p>
<p>对于normal subgroup 有aH=Ha</p>
<p>THEOREM 4</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191223192722282.png" alt="image-20191223192722282"></p>
<p>kernel：</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191223203347837.png" alt="image-20191223203347837"></p>
<h4 id="Other-mathamatical-structure"><a href="#Other-mathamatical-structure" class="headerlink" title="Other mathamatical structure"></a>Other mathamatical structure</h4><h5 id="Rings"><a href="#Rings" class="headerlink" title="Rings"></a>Rings</h5><p>对于环(S, +, ∗)，有两个二元操作符，*对于+是distributive的</p>
<p>当对于*的计算为associative时，该计算为环</p>
<p>commutative ring:If ∗ is associative and commutative, we call (S, +, ∗) a commutative ring. </p>
<p>monoid：If (S, ∗) is a monoid, then (S, +, ∗) is a ring with identity</p>
<p>THEOREM 1</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191223212405629.png" alt="image-20191223212405629"></p>
<h5 id="Fields"><a href="#Fields" class="headerlink" title="Fields"></a>Fields</h5><p>F is a field if every nonzero element x in F has a multiplicative inverse</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191223212800575.png" alt="image-20191223212800575"></p>
<p>THEOREM 2</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191223212822247.png" alt="image-20191223212822247"></p>
<h5 id="Fermat’s-Little-Theorem"><a href="#Fermat’s-Little-Theorem" class="headerlink" title="Fermat’s Little Theorem"></a>Fermat’s Little Theorem</h5><p>THEOREM 3</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191223213735717.png" alt="image-20191223213735717"></p>
<h3 id="第十章：Gruops-and-coding"><a href="#第十章：Gruops-and-coding" class="headerlink" title="第十章：Gruops and coding"></a>第十章：Gruops and coding</h3><h4 id="Coding-of-binary-information-and-Error-detection"><a href="#Coding-of-binary-information-and-Error-detection" class="headerlink" title="Coding of binary information and Error detection"></a>Coding of binary information and Error detection</h4><p>message：从有同时限字母表生成的有限字母序列</p>
<p>word：0 1序列</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191222171746055.png" alt="image-20191222171746055"></p>
<p>在传输过程中会因为noise发生信息错乱，因此需要encoding function（扩展字位）来保证error detection和correction</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191222172636094.png" alt="image-20191222172636094"></p>
<p>detects k error:如果在x和x<sub>t</sub>有k个或者更少的位不相同时，此时x<sub>t</sub>不是一个word</p>
<p>weight：一个word中1的个数</p>
<h5 id="Parity-check-code"><a href="#Parity-check-code" class="headerlink" title="Parity check code"></a>Parity check code</h5><p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191222183211766.png" alt="image-20191222183211766"></p>
<h5 id="Hamming-distance"><a href="#Hamming-distance" class="headerlink" title="Hamming distance"></a>Hamming distance</h5><p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191222183434882.png" alt="image-20191222183434882"></p>
<h5 id="minimum-distance"><a href="#minimum-distance" class="headerlink" title="minimum distance"></a>minimum distance</h5><p>就是在B<sup>m</sup>中不相同的encoding结果最小的</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191222183629802.png" alt="image-20191222183629802"></p>
<p>THEOREM 1  properties of distance function</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191222183513473.png" alt="image-20191222183513473"></p>
<p>THEOREM 2</p>
<p>如果其minimum distance为k+1，则其任意两个元素之间至少都有k+1个位不一样，因此有k位或者更少的不一样时肯定为错误word</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191222183812133.png" alt="image-20191222183812133"></p>
<h4 id="gruop-code"><a href="#gruop-code" class="headerlink" title="gruop code"></a>gruop code</h4><p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191222193118188.png" alt="image-20191222193118188"></p>
<p>THEOREM 3</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191222193444357.png" alt="image-20191222193444357"></p>
<p>+号为异或，·号为交，</p>
<p>THEOREM 4</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191222194127873.png" alt="image-20191222194127873"></p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191222194322693.png" alt="image-20191222194322693"></p>
<p>THEOREM 5</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191222194359255.png" alt="image-20191222194359255"></p>
<p>x为：（这样保证了x*H后每一项都是为双数的，因此结果为0）</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-2/image-20191222194841680.png" alt="image-20191222194841680"></p>

            </div>

            <!-- Post Comments -->
            

        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " target="_blank" rel="noopener" style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
