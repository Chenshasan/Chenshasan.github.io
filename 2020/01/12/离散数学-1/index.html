<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    URIEL |
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="miccall" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 4.2.0"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">URIEL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Java/">Java</a></li><li><a class="category-link" href="/categories/Python/">Python</a></li><li><a class="category-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a></li><li><a class="category-link" href="/categories/%E6%95%B0%E5%AD%A6/">数学</a></li><li><a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/Chenshasan/Typora-Lotebook-of-LGL" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="http://500px.com" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(http://b165.photo.store.qq.com/psb?/V13cLEEU1KBTPJ/3PqLppmDJ1w0fRWxT1nH6rjEvgu.obX*1QE3IrTgQFI!/b/dHS0Y2JrCQAA&amp;bo=IANYAgAAAAABB1k!&amp;rf=viewer_4);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >离散数学(1)</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h2 id="离散数学（1）"><a href="#离散数学（1）" class="headerlink" title="离散数学（1）"></a>离散数学（1）</h2><h3 id="第一章：fundamental"><a href="#第一章：fundamental" class="headerlink" title="第一章：fundamental"></a>第一章：fundamental</h3><h4 id="sets-and-subset"><a href="#sets-and-subset" class="headerlink" title="sets and subset"></a>sets and subset</h4><p>finite：有限的</p>
<p>cardinality：可数的（能够有|A|存在）</p>
<p>infinite：不可数的</p>
<h4 id="Operations-on-sets"><a href="#Operations-on-sets" class="headerlink" title="Operations on sets"></a>Operations on sets</h4><p>union:并集</p>
<p>intersection：交集</p>
<p>complement:补集：</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191228113614086.png" alt="image-20191228113614086"></p>
<p>symmetric differences:</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191228113717365.png" alt="image-20191228113717365"></p>
<p>THEOREM 1</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191228113756786.png" alt="image-20191228113756786"></p>
<p>THEOREM 2</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191228113821492.png" alt="image-20191228113821492"></p>
<p>THEOREM 3</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191228113835503.png" alt="image-20191228113835503"></p>
<h4 id="Sequences"><a href="#Sequences" class="headerlink" title="Sequences"></a>Sequences</h4><p>序列</p>
<p>有infinite/finite/explicit（能够用n清晰地表示第n位为什么）/recuisive（后一位可以用前一位表示）</p>
<p>characteristic function（特征函数）：</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191228114200919.png" alt="image-20191228114200919"></p>
<p>THEOREM 1</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191228114322932.png" alt="image-20191228114322932"></p>
<h3 id="第二章：逻辑"><a href="#第二章：逻辑" class="headerlink" title="第二章：逻辑"></a>第二章：逻辑</h3><p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/1570675758541.png" alt="1570675758541"></p>
<p>基本复习概念：p=&gt;q真假性与~p∪q相同</p>
<h3 id="第三章：计数"><a href="#第三章：计数" class="headerlink" title="第三章：计数"></a>第三章：计数</h3><p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/1570675603323.png" alt="1570675603323"></p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/1570675628032.png" alt="1570675628032"></p>
<p>基本复习概念：排列组合；鸽巢原理（存在性证明）；概率；递归——特征根方程</p>
<h3 id="第四章：relation-and-direction"><a href="#第四章：relation-and-direction" class="headerlink" title="第四章：relation and direction"></a>第四章：relation and direction</h3><p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/1571279485739.png" alt="1571279485739"></p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/1571279511590.png" alt="1571279511590">对称关系的矩阵是：该矩阵的转置与该矩阵相等（双向通道）</p>
<p>非对称关系的矩阵是：Mij=0，则Mji=1；并且有Mii=0（单向通道，无环）</p>
<p>反对称关系的矩阵是：Mii=1或0，且Mij若i不等于j，则必有Mij=0或者Mji=0（单向通道，可能有环）</p>
<p>传递关系：当M平方包含M时，这个矩阵表示的关系就有传递关系</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/1571280365472.png" alt="1571280365472"></p>
<h4 id="data-structure-of-relations-and-graphs"><a href="#data-structure-of-relations-and-graphs" class="headerlink" title="data structure of relations and graphs"></a>data structure of relations and graphs</h4><ol>
<li><p>通过链表来表示的方式</p>
<img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/Users/李甘霖/Dropbox/Typora-Lotebook-of-LGL/数学/离散数学.assets/image-20191029164617842.png" alt="image-20191029164617842" style="zoom:50%;">
</li>
<li><p>通过二维矩阵表示（因为二维矩阵能够表示relation，因此能够表示关系的指向）</p>
</li>
<li><p>通过两个数组来表示edge的指向——数组分别储存edge的头和尾，还有一个数组储存NEXT来表示edge的变化（类似于链表的地址位），也可以对每一个节点增加一个VERT数组，在VERT数组的相应索引下，储存了离开该节点的一个edge的标号（没有指向其他节点的节点的该VRET位为0），根据NEXT和VERT的配合，能够遍历完离开某一节点的所有edge</p>
<img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/Users/李甘霖/Dropbox/Typora-Lotebook-of-LGL/数学/离散数学.assets/image-20191029170457933.png" alt="image-20191029170457933" style="zoom: 50%;">

</li>
</ol>
<p>算法：</p>
<ol>
<li><p>判断是否具有传递性：（对于二维数组进行操作）<img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/Users/李甘霖/Dropbox/Typora-Lotebook-of-LGL/数学/离散数学.assets/image-20191029171642857.png" alt="image-20191029171642857" style="zoom:67%;"></p>
<p>算法复杂度：</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191029172130495.png" alt="image-20191029172130495"></p>
</li>
<li><p>在数组表示的方式中，添加edge的算法</p>
<img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/Users/李甘霖/Dropbox/Typora-Lotebook-of-LGL/数学/离散数学.assets/image-20191029175044298.png" alt="image-20191029175044298" style="zoom:67%;">

<p>（头和尾都增加，同时next也增加一位，将next的这一位指向vert[i]指向的那个edge，再将新增加的next赋给vert[i]）</p>
</li>
<li><p>在数组表示的方法中，检测是否有transive性质的算法：</p>
<img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/Users/李甘霖/Dropbox/Typora-Lotebook-of-LGL/数学/离散数学.assets/image-20191029180020117.png" alt="image-20191029180020117" style="zoom:50%;">

<p>当edge数量较多时，用二维数组比较好；当edge数量较少时，用多个数组较好</p>
</li>
</ol>
<h4 id="operations-on-relations"><a href="#operations-on-relations" class="headerlink" title="operations on relations"></a>operations on relations</h4><p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191029194201427.png" alt="image-20191029194201427"></p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191029194218370.png" alt="image-20191029194218370"></p>
<p>则：</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191029194252086.png" alt="image-20191029194252086"></p>
<img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/Users/李甘霖/Dropbox/Typora-Lotebook-of-LGL/数学/离散数学.assets/image-20191029194311488.png" alt="image-20191029194311488" style="zoom:67%;">

<p>对于R和S的关系，有如下操作：</p>
<p>THEOREM 1</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191029194402913.png" alt="image-20191029194402913"></p>
<p>THEOREM 2</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191029194736789.png" alt="image-20191029194736789"></p>
<p>THEOREM 3</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191029194857083.png" alt="image-20191029194857083"></p>
<p>THEOREM 4</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191029194940522.png" alt="image-20191029194940522"></p>
<p>THEOREM 5</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191029195019658.png" alt="image-20191029195019658"></p>
<p>Composition</p>
<p>THEOREM 6</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191029200155838.png" alt="image-20191029200155838"></p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191029200435931.png" alt="image-20191029200435931"></p>
<p>Closures：让R补充成满足自反性，对称性和传递性后补充的关系最少的一种R</p>
<p>THEOREM 7</p>
<p>矩阵乘法可交换</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191029200632316.png" alt="image-20191029200632316"></p>
<p>THEOREM 8</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191029200827300.png" alt="image-20191029200827300"></p>
<h4 id="Transitive-closure-and-Warshall’s-algorithm"><a href="#Transitive-closure-and-Warshall’s-algorithm" class="headerlink" title="Transitive closure and Warshall’s algorithm"></a>Transitive closure and Warshall’s algorithm</h4><p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191030143715238.png" alt="image-20191030143715238"></p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191030144137692.png" alt="image-20191030144137692"></p>
<h5 id="Warshall-algorithm"><a href="#Warshall-algorithm" class="headerlink" title="Warshall algorithm"></a>Warshall algorithm</h5><p>W算法即对于方向矩阵，从n=2开始不断扩展直到n=N，且扩展的方式从n-1到n时为M<sub>n-1</sub>*M<sub>n-1</sub>+M<sub>n-1</sub>，最后直到扩展到N</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191030150134630.png" alt="image-20191030150134630"></p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191030153408478.png" alt="image-20191030153408478"></p>
<h3 id="第五章：函数"><a href="#第五章：函数" class="headerlink" title="第五章：函数"></a>第五章：函数</h3><h4 id="functions"><a href="#functions" class="headerlink" title="functions"></a>functions</h4><p>mappings transformations</p>
<img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/Users/李甘霖/Dropbox/Typora-Lotebook-of-LGL/数学/离散数学.assets/image-20191031092622291.png" alt="image-20191031092622291" style="zoom:67%;">

<p>labeled digraph:所有的节点和edge都有实际意义的有向图</p>
<img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/Users/李甘霖/Dropbox/Typora-Lotebook-of-LGL/数学/离散数学.assets/image-20191031092842313.png" alt="image-20191031092842313" style="zoom:50%;">

<p>everywhere difined :定义域满</p>
<p>onto：值域满</p>
<p>one to one：一一对应，函数值不重复</p>
<p>invertible function：反函数</p>
<p>THEOREM 1</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191031093528166.png" alt="image-20191031093528166"></p>
<p>THEOREM 2</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191031093948461.png" alt="image-20191031093948461"></p>
<p>THEOREM 3</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191031094144445.png" alt="image-20191031094144445"></p>
<p>THEOREM 4</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191031094705184.png" alt="image-20191031094705184"></p>
<h4 id="functions-for-computer-secience"><a href="#functions-for-computer-secience" class="headerlink" title="functions for computer secience"></a>functions for computer secience</h4><p>特征函数：</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191106162724505.png" alt="image-20191106162724505"></p>
<p>在cs中使用的函数主要有：</p>
<ul>
<li>基本的对应函数</li>
<li>向上取整:ceiling function</li>
<li>向下取整：floor function </li>
<li>幂函数 base 2 exponential function，对数函数</li>
<li>Boolean fuction返回值是一个bolean类型</li>
</ul>
<h5 id="Hash-function"><a href="#Hash-function" class="headerlink" title="Hash function"></a>Hash function</h5><p>创建一系列的链表，以及通过函数的对应方式决定新加入的元素应该添加到哪个链表上，同时这个函数也能够决定在哪个链表上搜索想要的元素</p>
<ul>
<li>hash function的基本原理是，将元素储存在链表后，控制每个链表的大小相同，所以一般通过取模的方式来决定元素在哪个链表中（模相同的结果在同一个链表）</li>
<li>如果又出现了一个元素，且此时链表的元素已经满了，需要一个解决collision的方式，基本的解决collision的方式有：在该链表后强制加入现在的元素/将key分成几个部分之后再储存</li>
</ul>
<h5 id="Fuzzy-Set"><a href="#Fuzzy-Set" class="headerlink" title="Fuzzy Set"></a>Fuzzy Set</h5><p>比较模糊的函数表示方式，往往表示一个范围，如0&lt;f(x)&lt;1，则此时f为一定程度的关于x的fuzzy函数</p>
<ul>
<li>fuzzy函数会定义两个最值，然后在中间的值通过x-min/(max-min)来定义其程度</li>
<li>定义程度的函数可以改变</li>
</ul>
<h5 id="Fuzzy-Set-Operations"><a href="#Fuzzy-Set-Operations" class="headerlink" title="Fuzzy Set Operations"></a>Fuzzy Set Operations</h5><p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191106154457335.png" alt="image-20191106154457335"></p>
<h4 id="Growth-of-functions"><a href="#Growth-of-functions" class="headerlink" title="Growth of functions"></a>Growth of functions</h4><p>大O表示法：O(f)即为增长速度大于O(f)的，一般去找最小的关于f的大O表示</p>
<p>same order:同阶，O(f)=g,O(g)=f,同时有lower order  /higher order</p>
<p> big-theta ：同阶，即增长速度相同</p>
<p>关于增长速度的判定：</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191106173813688.png" alt="image-20191106173813688"></p>
<h4 id="permutation-function"><a href="#permutation-function" class="headerlink" title="permutation function"></a>permutation function</h4><p>permutation：对于自身的映射，这种映射是对每个自身的元素进行一个映射，是一个一一对应关系</p>
<p>permutation的本意是计算一件事情序列实施共有多少中方法，permutation function为对于一个集合的实施方法的映射</p>
<p>两个permutation的结合也是一个permutation</p>
<p>THEOREM 1</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191106190756058.png" alt="image-20191106190756058"></p>
<p>同时cycle permutation拥有的元素相同时，其对应关系与顺序无关</p>
<p>当两个cycle permutation都属于同一个集合且两个cycle permutation没有公共交集元素时，被称为是disjiont</p>
<p>THEOREM 2</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191106191428108.png" alt="image-20191106191428108"></p>
<p>transposotion：长度为2的cycle</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191106194046772.png" alt="image-20191106194046772"></p>
<p>Corollary 1</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191106195216761.png" alt="image-20191106195216761"></p>
<p>THEOREM 3</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191106195312450.png" alt="image-20191106195312450"></p>
<p>THEOREM 4</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191106195402038.png" alt="image-20191106195402038"></p>
<h3 id="第六章：Order-Relations-and-Structures"><a href="#第六章：Order-Relations-and-Structures" class="headerlink" title="第六章：Order Relations and Structures"></a>第六章：Order Relations and Structures</h3><h4 id="partially-ordered-sets"><a href="#partially-ordered-sets" class="headerlink" title="partially ordered sets"></a>partially ordered sets</h4><h5 id="partial-order"><a href="#partial-order" class="headerlink" title="partial order:"></a>partial order:</h5><p>对于集合A的关系R,如果R是reflective antisymmetrick transitive的时候，则称其为partial order</p>
<p>poset：集合A</p>
<p>eg:</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191112203622715.png" alt="image-20191112203622715"></p>
<p>dual: poset(A,R<sup>-1</sup>)是poset(A,R)的dual，R<sup>-1</sup>是R的dual</p>
<p>comparable：当A,B能够用一种方式中，则A，B是comparable的</p>
<ul>
<li>在一个poset中，不是所有的元素都能够被比较，如果所有的元素都能被比较，则被称为linear ordered set</li>
</ul>
<p>THEOREM 1</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191112205859558.png" alt="image-20191112205859558"></p>
<h5 id="lexicographic："><a href="#lexicographic：" class="headerlink" title="lexicographic："></a>lexicographic：</h5><ul>
<li>先判断a，当a相等时，再判断b</li>
</ul>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191112210357857.png" alt="image-20191112210357857"></p>
<ul>
<li>对于多维的lexicographic有：</li>
</ul>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191112210601658.png" alt="image-20191112210601658"></p>
<ul>
<li>也称为dictionary list，其顺序和字典很相似，且有<img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/Users/李甘霖/Dropbox/Typora-Lotebook-of-LGL/数学/离散数学.assets/image-20191112211015622.png" alt="image-20191112211015622" style="zoom:50%;">，即长度小也满足该关系</li>
</ul>
<p>THEOREM 2</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191112211138744.png" alt="image-20191112211138744"></p>
<p>除了自反之外，没有其他的环（因为有偏序作用）</p>
<p>hasse diagram:简化后没有方向的关系图，如下图5（简化的过程为将指向图中有串联性的多余箭头去掉）</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191113191058736.png" alt="image-20191113191058736"></p>
<ul>
<li>对于一个poset的hasse diagram H，其dual poset的hasse diagram是颠倒过来的H</li>
</ul>
<h5 id="Topological-sorting"><a href="#Topological-sorting" class="headerlink" title="Topological sorting"></a>Topological sorting</h5><p>对于一个partial order，将其表示成线性的序列成为topological sorting</p>
<h5 id="isomorphism"><a href="#isomorphism" class="headerlink" title="isomorphism"></a>isomorphism</h5><p>一个partial order到另一个partial order的一一对应映射</p>
<ul>
<li>两个isomorphic 的posets有一样的hasse diagram</li>
<li>对于任意一个hasse diagram图，当图中所有的a被f(a)所替代后，仍然是个hasse diagram</li>
</ul>
<h4 id="Extremal-elements-of-partially-ordered-sets"><a href="#Extremal-elements-of-partially-ordered-sets" class="headerlink" title="Extremal elements of partially ordered sets"></a>Extremal elements of partially ordered sets</h4><p>THEOREM 1</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191114094420880.png" alt="image-20191114094420880"></p>
<p>通过最小元素来判断拓扑排序的算法：</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191114094755285.png" alt="image-20191114094755285"></p>
<p>THEOREM 2</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191114095951322.png" alt="image-20191114095951322"></p>
<p>great element——unit element</p>
<p>least element——zero element</p>
<p>upper bound：一个元素是一个集合的上界，least upper bound：最小上届</p>
<p>lower bound ：一个元素是一个集合的下届，grateset lower bound：最大下届</p>
<p>THEOREM 3</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191114101024857.png" alt="image-20191114101024857"></p>
<p>THEOREM 4</p>
<p>即A和isomorphic的A<sup>‘</sup>的上界下界有一一对应关系</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191114101603909.png" alt="image-20191114101603909"></p>
<h4 id="Lattices"><a href="#Lattices" class="headerlink" title="Lattices"></a>Lattices</h4><p>定义：一个每两个元素组成的子集都拥有一个最小上界和一个最大下届的poset</p>
<p>jion: LUB({a, b}) ，用a ∨ b表示</p>
<p>meet:GLB({a, b})，用 a ∧ b表示</p>
<p>（两个元素有明确的上界和下届或者两个元素可以比较）</p>
<p>THEOREM 1</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191114174000086.png" alt="image-20191114174000086"></p>
<ul>
<li>对于一个lattices的子集，其子集可能是lattices，也可能不是</li>
</ul>
<h5 id="isomorphic-lattices："><a href="#isomorphic-lattices：" class="headerlink" title="isomorphic lattices："></a>isomorphic lattices：</h5><p>就是对应关系后的lattice</p>
<h5 id="properties"><a href="#properties" class="headerlink" title="properties:"></a>properties:</h5><p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191114175042197.png" alt="image-20191114175042197"></p>
<p>THEOREM 2</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191114175103798.png" alt="image-20191114175103798"></p>
<p>THEOREM 3</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191114194134218.png" alt="image-20191114194134218"></p>
<p>THEOREM 4</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191114194226809.png" alt="image-20191114194226809"></p>
<h5 id="bounded"><a href="#bounded" class="headerlink" title="bounded"></a>bounded</h5><p>当一个lattices既含有最大元素也含有最小元素时，被称为bounded</p>
<p>THEOREM 5</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191114195053980.png" alt="image-20191114195053980"></p>
<p>同时lattices可能有distributed 的性质</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191114195204918.png" alt="image-20191114195204918"></p>
<p>THEOREM 6</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191114195419061.png" alt="image-20191114195419061"></p>
<img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/Users/李甘霖/Dropbox/Typora-Lotebook-of-LGL/数学/离散数学.assets/image-20191114195439325.png" alt="image-20191114195439325" style="zoom:50%;">

<p>即如果一个lattice的hasse图的映射是上图两种映射中的一种，则是不distrubuted的</p>
<p>THEOREM 7</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191116195050708.png" alt="image-20191116195050708"></p>
<p> Dn：定义为由可除性形成的lattice</p>
<h4 id="Finite-Boolean-Algebras"><a href="#Finite-Boolean-Algebras" class="headerlink" title="Finite Boolean Algebras"></a>Finite Boolean Algebras</h4><p>THEOREM 1</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191121170806140.png" alt="image-20191121170806140"></p>
<p>理论的本质在于：集合的属于关系所形成的lattice只和集合的元素数量和集合之间元素的属于关系有关，和集合里面元素的本质无关</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191125104539738.png" alt="image-20191125104539738"></p>
<p>这样的集合形成的哈希图称为Bn，Bn的节点数量一定为2<sup>n</sup></p>
<p>与Bn能够对应的lattice称为Boolean Algebra</p>
<p>THEOREM 2</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191125105925642.png" alt="image-20191125105925642"></p>
<p>如果n是几个不同的素数的乘积，那么Dn是Boolean algebra</p>
<p>THEOREM 3 substitution rule for boolean algebras</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191125110749340.png" alt="image-20191125110749340"></p>
<p>因此有：</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191125111146557.png" alt="image-20191125111146557"></p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191125111209160.png" alt="image-20191125111209160"></p>
<p>THEOREM 4</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191125112501286.png" alt="image-20191125112501286"></p>
<h4 id="Boolean-polynomial"><a href="#Boolean-polynomial" class="headerlink" title="Boolean polynomial"></a>Boolean polynomial</h4><p>=&gt;用boolean多项式来形成逻辑电路</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191125143342020.png" alt="image-20191125143342020"></p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191125143320793.png" alt="image-20191125143320793"></p>
<p>gate: x ∧ y   inverter： x<sup>‘</sup></p>
<p>逻辑电路的表示</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191125150100989.png" alt="image-20191125150100989"></p>
<h4 id="Circuit-design"><a href="#Circuit-design" class="headerlink" title="Circuit design"></a>Circuit design</h4><p>通过boolean函数的特性设置电路</p>
<p>THEOREM 1</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191125152911080.png" alt="image-20191125152911080"></p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191125153246372.png" alt="image-20191125153246372"></p>
<p>THEOREM 2</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191125153355565.png" alt="image-20191125153355565"></p>
<h5 id="Karnaugh-map"><a href="#Karnaugh-map" class="headerlink" title="Karnaugh map"></a>Karnaugh map</h5><p>x为0的项用x<sup>‘</sup>表示，为1的项为x表示，y相同，矩阵的值为f的值</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191125153917789.png" alt="image-20191125153917789"></p>
<p>对于B<sub>3</sub>进行三维分析：</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191125191202250.png" alt="image-20191125191202250"></p>
<p>当f可知时，其三维表示为：</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191125192455303.png" alt="image-20191125192455303"></p>
<p>同理，四维如图所示：</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191125192710739.png" alt="image-20191125192710739"></p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191125192902436.png" alt="image-20191125192902436"></p>
<h5 id="minterm"><a href="#minterm" class="headerlink" title="minterm"></a>minterm</h5><p>通过最小的组成元素所表达出来的布尔代数，如</p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191125194825341.png" alt="image-20191125194825341"></p>
<h4 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h4><p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191125195652753.png" alt="image-20191125195652753"></p>
<p><img src="/2020/01/12/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-1/image-20191125195717050.png" alt="image-20191125195717050"></p>

            </div>

            <!-- Post Comments -->
            

        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " target="_blank" rel="noopener" style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
