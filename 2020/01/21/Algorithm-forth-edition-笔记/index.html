<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    URIEL |
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="miccall" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 4.2.0"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">URIEL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Java/">Java</a></li><li><a class="category-link" href="/categories/Python/">Python</a></li><li><a class="category-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a></li><li><a class="category-link" href="/categories/%E6%95%B0%E5%AD%A6/">数学</a></li><li><a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/Chenshasan/Typora-Lotebook-of-LGL" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="http://500px.com" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(http://m.qpic.cn/psc?/V13cLEEU1KBTPJ/WntOtr8rW56pbv0uxxE6dRagjdaOvv.eU795*cfUmjx84b78ccsB8ENa.x3GFBsNcHdn9.yYNRYpVUuwKDXEdh1VcBnkJlOx9PE2t1NsFpo!/b&amp;bo=gAc4BAAAAAARB4s!&amp;rf=viewer_4);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >Algorithm(forth edition)笔记</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <p>Algorithms (forth edition) 笔记</p>
<h3 id="排序："><a href="#排序：" class="headerlink" title="排序："></a>排序：</h3><h4 id="1-选择排序"><a href="#1-选择排序" class="headerlink" title="1.选择排序"></a>1.选择排序</h4><p>每一次取出剩余项中最小的一项，排到最前面，直到所有项全都被排好</p>
<h4 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2.插入排序"></a>2.插入排序</h4><p>每一次取出一项，插入到前面已经排序的项之中</p>
<h4 id="3-Shell-排序"><a href="#3-Shell-排序" class="headerlink" title="3.Shell 排序"></a>3.Shell 排序</h4><p>设定一个n，在一串长数组之中每隔n个抽取一个数形成小型数列，将小型数列进行排序，然后逐渐缩小n到一，完成最终的排序（O（n的二分之三次方））</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570536951190.png" alt="1570536951190">4.merge排序</p>
<p>结合两个顺序数组来组成更大的顺序数组。</p>
<p>Top-down mergesort，不断将数组分成更小的数组，直到可以进行两两比较，再进行合并，合并到最大数组为止</p>
<p>=&gt;提升top-dowm mergesort的效率，可以通过用insertion sort排布小型数组，检测数组是否已经排好顺序，消除复制到辅助数组的操作</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570536977208.png" alt="1570536977208"></p>
<p>bottom-down mergesort近似于top-down mergesort，通过递归进行排序，先两两比较，再四个之间进行比较，再八个之间进行排序类推到最后合成最终数组</p>
<p>（所有基于比较的排序算法最少的次数只能达到NlogN次级别）</p>
<h4 id="5-quicksort"><a href="#5-quicksort" class="headerlink" title="5.quicksort"></a>5.quicksort</h4><p>基于divide and conquer进行排序，基本算法为——选取第一个数，然后将大于它的排在一遍，小于他的排在一遍，再将两边的数进行排序</p>
<p>在每一次排序中都使用隔板将两边的数隔开（通过递归实现），最终完成排序（每次的隔板选择都具有随机性，因此这个算法也具有随机性）</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570536997092.png" alt="1570536997092"></p>
<p>Entropy-optimal sorting，类似于quicksort，但将与隔板数相同大小的数也归为一类，用三类区分隔板</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570537019884.png" alt="1570537019884"></p>
<h4 id="6-priority-queues"><a href="#6-priority-queues" class="headerlink" title="6.priority queues"></a>6.priority queues</h4><p>这是一种所有逻辑近似于冒泡排序的方式，将顺序先进行heap sort然后再sortdowm,主要算法如下</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570537033798.png" alt="1570537033798"></p>
<p>前期有较多的预备知识，如priority queues的基本操作是不断的插入并进行最大值的取出，这一操作同时在heapsort里面蕴含了swim() 和 sink()两种方法，</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570537068266.png" alt="1570537068266"></p>
<p>swim()是将小的数字移上去</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570537083757.png" alt="1570537083757"></p>
<p>sink()是将数字再进行正常排列</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570537099925.png" alt="1570537099925"></p>
<p>这两种方式构成了sortdown的基本逻辑，即不断将最小的数字移到第一位（原第一位作为最大数被去除），再将所有的链进行sink()排列好</p>
<p>而heap constuction就是用sink()将序列整理好，方便sortdown的进行。</p>
<p>heapsort使用了最多2NlgN次的交换和比较次数</p>
<h4 id="7-应用"><a href="#7-应用" class="headerlink" title="7.应用"></a>7.应用</h4><p>排序方法的选择</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570537120097.png" alt="1570537120097"></p>
<p>=&gt;quick sort往往是最快的排序方法，但如果稳定性很重要且空间足够，可以选择mergesort，有些情况下可以选择不用comparator来进行比较，直接比较基本数据即可</p>
<p>（具有稳定性的排序方法有insertion sort and mergesort）</p>
<h3 id="搜索："><a href="#搜索：" class="headerlink" title="搜索："></a>搜索：</h3><h4 id="1-elementary-symbol-tables"><a href="#1-elementary-symbol-tables" class="headerlink" title="1.elementary symbol tables"></a>1.elementary symbol tables</h4><p>最基础的搜索表单有如下应用：</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570537134838.png" alt="1570537134838"></p>
<p>作为搜索表单，基本api为</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570537165015.png" alt="1570537165015"></p>
<p>表单的基础查找方式为二分法查找，这种查找方式要求在插入数据时，先将数据排好 ，在搜索数据是，选择数组中间的key（mid），如果给定的key大于key（mid）则在右边的子数组中找，小于key（mid）则在数组左边的子数组中找。</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570537182999.png" alt="1570537182999"></p>
<p>查找时最多使用lgN+1次比较，插入数据时最多为2的n次方次进入数组。</p>
<h4 id="2-binary-search-trees"><a href="#2-binary-search-trees" class="headerlink" title="2.binary search trees"></a>2.binary search trees</h4><p>一个二分树也是基本树状，每个节点有两个支树，左支树上面的节点都比源节点小，右支树上面的节点都比源节点大</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570537199997.png" alt="1570537199997"></p>
<p>基本操作有search 和 insert</p>
<p>search操作由get()方法实现，基本逻辑就是沿着二分树的特质进行搜索，如果树中有这个节点则进行匹配并返回答案，没有则返回null</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570537214244.png" alt="1570537214244"></p>
<p>insert操作由put()方法实现，搜索逻辑类似于get(),搜索到具体位置后插入节点</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570537227756.png" alt="1570537227756"></p>
<p>寻找minimum和maximum就是找到最左边或者最右边的支树</p>
<p>selection操作有一个rank k，selection是选出从小到大第k+1位的数，即这个节点有k个比他小的节点，算法逻辑是不断往左树上找，如果现有的一个节点左树的节点大于k，则进入这个左树寻找，如果现有的节点小于k，则k=k-左树节点数-1（这个1是现在立足的节点），然后进入右树寻找，直到k为0</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570537243651.png" alt="1570537243651"></p>
<p>floor 和ceiling操作，floor是寻找恰好小于k的一个数</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570537257347.png" alt="1570537257347"></p>
<p>delete操作，是删除节点，如果节点只有一个子节点，则直接用子节点替代它，如果节点有两个以上子节点，则选择恰好大于它的一个子节点替代他</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570537272486.png" alt="1570537272486"></p>
<h4 id="3-balanced-search-tree"><a href="#3-balanced-search-tree" class="headerlink" title="3.balanced search tree"></a>3.balanced search tree</h4><p>（在这里吹爆algorithm，维基上红黑树的讲解我看的云里雾里，还是algorithm流x，一讲便通环环相扣，吹爆！！！</p>
<p>balanced search tree延伸了binary search tree的逻辑，但添加了三个分支的节点，如下图，左边为小于E J的节点，中间为在E J中间的节点，右边为大于E J的节点，search方法与二分法逻辑相同，不多赘述</p>
<p>插入方法的逻辑为，每一次插入时都尽量的凑成三个分支的节点，如在H节点下插入I节点，则此节点变为H I节点，如果新插入的节点是插入到三个分支的节点上，则进行分裂，分裂方式如图所示</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570537318651.png" alt="1570537318651">)<img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570537340159.png" alt="1570537340159"></p>
<p>基本的balanced search tree逻辑如上，而红黑树的逻辑则是基于balanced search tree进行</p>
<p>Red-black BSTs：</p>
<p>红黑树的逻辑，即为将balanced search tree中三个分支的节点，转化为红线链接的两个节点，</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570537363309.png" alt="1570537363309"></p>
<p>在红黑树中插入有如下原则，即1）永远保持红线向左倾  2）一个节点有两条红线时会进行如balanced search tree中四个分支节点的分裂</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570537379302.png" alt="1570537379302"></p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570537394136.png" alt="1570537394136"></p>
<p>因此在红黑树中插入时会常有较大的树形结构变化，如下图中Insert S中insert H的 步骤</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570537410165.png" alt="1570537410165"></p>
<p>insert的H会在R下，且用红线链接，则有R此时与E链接，且R与E链接为红线，但此时红线为右倾，则转换红线的方向为左倾，完成变换</p>
<p>红黑树的长度不会超过2lgN</p>
<h4 id="4-Hashtable"><a href="#4-Hashtable" class="headerlink" title="4.Hashtable"></a>4.Hashtable</h4><p>了解hashtable的本质首先确定这是一种映射关系，我们将M个keys映射到N个index上，这个映射过程使用的是hash function，而每个index可能对应着多个keys，所以会产生搜索结果的冲突，要解决这种冲突，即需要collision-solution</p>
<p>hash fuction</p>
<p>基本的对应方式为hashcode()(M为hashtable中的index数量)</p>
<p>正整数取k%M，在0到1之间的浮点数则取k*M，然后取最接近这一结果的Index，字符串则采取特殊算法，其中R一般在java中为31<img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570537427052.png" alt="1570537427052"></p>
<p>而合成的keys则是将每个部分分开计算hashcode</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570537441013.png" alt="1570537441013"></p>
<p>hashcode最后再转换为Index很简单，直接与0x7fffffff做与运算即可（即去掉符号位的影响）</p>
<p>java对于基本的数据类型都有hashcode的方法（ <code>String</code>, <code>Integer</code>, <code>Double</code>, <code>Date</code>, and <code>URL</code>），其他类型的hashcode可自行定义，但需要有类似于.equals()的传递性</p>
<p>collsion-solution</p>
<p>两种基本的处理办法，一种为在每一个index中都添加一个链表，则搜索方法变为先搜索keys对应的index进入此链表，再在链表里面搜索keys</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570537455943.png" alt="1570537455943"></p>
<p>另一种为取M个index（M大于keys的数量N），则如果一个index有了keys，将也对应这个Index的Keys往下接着放，则会有一个index下面临近几个index所储存的keys全部对应相同的index，因此搜索时会出现三种情况</p>
<ol>
<li>直接搜索到相应的key，search hit</li>
<li>该index储存值为null，search miss</li>
<li>该index储存不是相应keys，往下找直到找到或找不到相应keys</li>
</ol>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570537470042.png" alt="1570537470042"></p>
<h3 id="图表："><a href="#图表：" class="headerlink" title="图表："></a>图表：</h3><h4 id="1-undirected-graphs"><a href="#1-undirected-graphs" class="headerlink" title="1.undirected graphs"></a>1.undirected graphs</h4><p>基本的graph类型api如下</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570172305955.png" alt="1570172305955"></p>
<p>最重要的方法adj是一个链表的链表，数据结构如图所示</p>
<img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/Users\李甘霖\AppData\Roaming\Typora\typora-user-images\1570172363027.png" alt="1570172363027" style="zoom: 50%;">

<p>undirected graph有两种搜索方法，depth first search搜索其中某一条从节点v能到节点s的路径，breadth-first search搜索最短的从节点v到节点s的路径</p>
<p>depth-first search主要有两个类</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570172515591.png" alt="1570172515591"></p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570172531799.png" alt="1570172531799"></p>
<p>基本搜索逻辑为先从s节点递归式遍历一遍，遍历s节点的所有adj的节点，再遍历adj节点所有adj的节点，依次类推，每次遍历时将能够连接的节点marked，因此能够到达s节点的所有节点全部被marked，然后再去求这些节点到s节点的路径，求路径时每个节点有一个固定的edgeTo()方法，能返回一个指定的连接到该节点的节点，通过这样的顺序不断edgeTo(),直到从节点v到达节点s，因此中间的所有节点即为v到s的路径</p>
<p>breadth-first search</p>
<p>基本逻辑类似于depth-first search，先遍历一遍，然后每次与s相邻的节点都会marked，但breadth-first search是从s开始，能够通过一个edge直接到达s的edgeTo()的结果全为s，而与s相邻的节点再相邻的节点是通过两个edge到达s，则这些节点的edgeTo()的结果即全为与s距离为一个edge的节点，因此能够搜索到这些节点到s的最短距离</p>
<p>symbol graphs</p>
<p>对于一些节点名为string或其他形式的graph，一般采取如图的数据结构</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570175749372.png" alt="1570175749372"></p>
<h4 id="2-directed-graphs"><a href="#2-directed-graphs" class="headerlink" title="2.directed graphs"></a>2.directed graphs</h4><p>directed graph的逻辑基本类似于undirected graph,但图表多了方向，所以在进行DFS和BFS时需要根据顺序进行marked，即为沿着箭头方向不断marked，然后再来求其他节点是否有路径到源节点以及到源节点的最短路径。</p>
<p>cycle和DAGs(DAG为有向无环图表)</p>
<p>cycle detection很简单，同样运用DFS的逻辑，每次发散到一个节点即进行marked，如果出现该节点的下一轮节点已经被marked的时候，则出现了环</p>
<p>DAG有三种排列方法，即将逐渐mark的节点通过顺序展现出来，preoder——在递归开始之前进行添加进queue中，postorder——在递归完成后添加进queue中，reversePost——在递归完成后添加到stack中</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570181414486.png" alt="1570181414486"></p>
<p><em>Topological sort</em>即使将DAG通过reversePost排序之后，会出现所有的edge指向都是从之前的节点指向之后的节点</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570181537235.png" alt="1570181537235"></p>
<p>Strong connectivity——可直接认为是undirect graph，因为每个节点之间的连接都是双向的</p>
<p>transive closure——一种形式的directed graph，但这种形式的directed graph即类似于右边的矩阵图，当且仅当原来的directed graph中节点v能够到达节点w时，这个transive closure才会有从v连接到w的edge</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570185235461.png" alt="1570185235461"></p>
<h4 id="3-minimum-spanning-trees"><a href="#3-minimum-spanning-trees" class="headerlink" title="3.minimum spanning trees"></a>3.minimum spanning trees</h4><p>定义：minimum spanning trees是指的能够用最少的edge连接所有的节点的树</p>
<p>基本操作：cut和circle，cut是切断树中任何两个节点的连接，树将会变成两个分minimum spanning trees，circle是指的连接任何两个节点，树将会出现环</p>
<p><strong>Greedy MST algorithm</strong></p>
<p>将所有的节点想象成两方，黑线连接的节点始终在一方，其他没有连接的节点可自由分配，直到连接完所有的节点</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570190933323.png" alt="1570190933323"></p>
<p>当edge有不同的重量属性时，有如下的连接方式</p>
<p><strong>Prim’s algorithm</strong></p>
<p>是从一个节点开始，每一次纳入一个新的节点，直到形成树</p>
<p>Prim’s algorithm拥有两种连接方式，第一种为lazy implementation，第二种为eager implementation</p>
<img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/Users\李甘霖\AppData\Roaming\Typora\typora-user-images\1570191081345.png" alt="1570191081345" style="zoom:50%;">

<p>lazy implementation即将所有的edge通过重量排序出来，已经连接在树中的节点之间不能再有edge,其他的节点连接即选择质量最小的edge来连接</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570191246325.png" alt="1570191246325"></p>
<p>eager implementation是修改lazy implementation，删除树中间节点之间的edge，同时因为每个节点添加时都是用的最小的连接，即直接选取该节点连接到树时最小重量的连接edge</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570191562165.png" alt="1570191562165"></p>
<p><strong>Kruskal’s algorithm</strong></p>
<p>把所有节点之间的edge全都排序，选择重量最小的连接，同时删除树中节点的连接edge</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570191616978.png" alt="1570191616978"></p>
<h4 id="4-shortset-paths"><a href="#4-shortset-paths" class="headerlink" title="4.shortset paths"></a>4.shortset paths</h4><p>有向图表的最短路径即为有向图表的最小重量的路径，这一章的研究方法不是以及节点为重点，而是以edge为重点</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570275499530.png" alt="1570275499530"></p>
<p>求最短路径的api</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570275560972.png" alt="1570275560972"></p>
<p>基本数据形式为<img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570275597184.png" alt="1570275597184"></p>
<p>即edgeTo()是指从源节点到该点的最短edge，distTo()是从源节点到该点的最短路径，这里的逻辑基本为先计算源节点到距离一个edge节点的最短路径，此时有了第一批distTo()出现，然后再依次计算其他节点的distTo()</p>
<p>这里对于edge的操作为relaxation，即对于edge指向的点，如果直接的distTo[v]+e.weight&lt;distTo[w],则将edgeTo[w]选择为这个e</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570275839916.png" alt="1570275839916"></p>
<p>所以对于节点进行relax操作即为遍历指向这个节点的所有edge，选择最轻的edge确定这一edgeTo()</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570276585782.png" alt="1570276585782"></p>
<p><strong>Dijkstra’s algorithm</strong></p>
<p>这一算法的逻辑为先把所有的distTo()设为无穷，源节点自身的distTo()设为0，然后开始确定edgeTo()，同时确定distTo()，然后一直relax直到所有的点到源节点的距离全都确定。</p>
<p><strong>Acyclic edge-weighted digraphs</strong></p>
<p>这一算法是对于DAG即有向无环图的算法，基于有向无环图的拓扑排序实现，</p>
<p><em>Single-source shortest paths problem in edge-weighted DAGs</em>（单源节点最短路径）</p>
<p>根据拓扑排序的顺序，一个接一个的对节点进行relax，然后就能求出其最短路径</p>
<p><em>Single-source longest paths problem in edge-weighted DAGs</em>（单源节点最长路径）</p>
<p>方法同上，只需将每次relax的最短edge换成最长edge即可</p>
<p><em>Critical path method</em></p>
<p>这个方法中algorithm给了一个例子，即给定一连串的工作以及对应的工作时间，限制条件为有些工作必须在其他工作之前做完，求所有工作做完的最短时间。</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570277109230.png" alt="1570277109230"></p>
<p>这里的基本逻辑如下图，将所有工作的起点和终点都看作两个节点，然后中间的edge weight为时间（图中此edge为黑色），而有些工作一定要在其他工作之前完成，因此也有有向edge存在（图中此edge为红色），所有的关系形成之后即为下图没有s，t节点的样子。而这些工作是可以并列做的，因此可以将没有箭头指向的所有节点全都连接到s节点上，将所有没有箭头指出的节点全都连接到t节点上，此时也能保证所有的工作已做完，形成下图。</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570277147129.png" alt="1570277147129"></p>
<p>完成所有工作的最短时间即为s到t的最长路径。</p>
<p><img src="/2020/01/21/Algorithm-forth-edition-%E7%AC%94%E8%AE%B0/1570277773686.png" alt="1570277773686"></p>

            </div>

            <!-- Post Comments -->
            

        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " target="_blank" rel="noopener" style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
